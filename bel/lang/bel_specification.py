#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This file contains functions to retrieve and return BEL object specifications.
"""

import glob
import os
import re
import copy
import sys
import yaml
import json
import click
from typing import Mapping, List, Any

import logging
log = logging.getLogger(__name__)

'''
Keys available in enhanced spec_dict:

- 'version_underscored'
- 'parser_path'
- 'jinja_template'
- 'relation_list'
- 'relation_to_short'
- 'relation_to_long'
- 'relations'
- 'function_list'
- 'function_to_short'
- 'function_to_long'
- 'functions'
- 'modifier_list'
- 'modifier_to_short'
- 'modifier_to_long'
- 'modifier_functions'
- 'function_signatures'
- 'default_namespaces'
'''


def get_specification(version: str) -> Mapping[str, Any]:
    """Get BEL Specification

    The json file this depends on is generated by belspec_yaml2json from the
    manually created and updated BEL Specification yaml file and is kept up to date using
    `make update_ebnf` or `make update_parsers`.  You can also run `belspec_yaml2json`
    directly as it's added as a command by pip install.
    """

    spec_dict = {}

    bel_versions = get_bel_versions()
    if version not in bel_versions:
        log.error('Cannot get unknown version BEL specification')
        return spec_dict

    # use this variable to find our parser file since periods aren't recommended in python module names
    version_underscored = version.replace('.', '_')

    json_fn = f'{os.path.dirname(__file__)}/versions/bel_v{version_underscored}.json'
    with open(json_fn, 'r') as f:
        spec_dict = json.load(f)

    return spec_dict


@click.command()
def belspec_yaml2json():
    """Enhance BEL specification and save as JSON file

    Load all BEL Specification YAML files and convert to JSON files
    after enhancing them.  Also create a bel_versions.json file with
    all available BEL versions for fast loading.


    """

    current_dir = os.path.dirname(__file__)

    bel_versions = []
    bel_versions_fn = f'{current_dir}/versions/bel_versions.json'

    spec_files = glob.glob(f'{current_dir}/versions/bel_v*.yaml')
    for fn in spec_files:
        try:
            spec_dict = yaml.load(open(fn, 'r').read())
        except Exception as e:
            log.error('Warning: BEL Specification {fn} could not be read. Cannot proceed.'.format(fn))
            sys.exit()

        json_fn = fn.replace('yaml', 'json')

        bel_versions.append(spec_dict['version'])

        # admin-related keys
        spec_dict['version_underscored'] = spec_dict['version'].replace('.', '_')

        # get the current directory name, and use that to find the version's parser file location
        cur_dir_name = os.path.basename(os.path.dirname(os.path.realpath(__file__)))
        parser_path = 'bel.{}.versions.parser_v{}'.format(cur_dir_name, spec_dict['version_underscored'])
        spec_dict['parser_path'] = parser_path

        # keys related to creation of EBNF file inside yaml_to_ebnf
        spec_dict['jinja_template'] = 'bel.ebnf.j2'

        # add relation keys relation_list, relation_to_short, relation_to_long
        spec_dict = add_relations(spec_dict)
        # add function keys function_list, function_to_short, function_to_long
        spec_dict = add_functions(spec_dict)
        # add modifier keys modifier_list, modifier_to_short, modifier_to_long
        spec_dict = add_modifiers(spec_dict)

        spec_dict = enhance_function_signatures(spec_dict)

        spec_dict = enhance_default_namespaces(spec_dict)

        spec_dict = add_function_signature_help(spec_dict)

        with open(json_fn, 'w') as f:
            json.dump(spec_dict, f)

    with open(bel_versions_fn, 'w') as f:
        json.dump(bel_versions, f)


def add_function_signature_help(spec_dict: dict) -> dict:
    """Add function signature help

    Simplify the function signatures for presentation to BEL Editor users
    """
    for f in spec_dict['function_signatures']:
        for argset_idx, argset in enumerate(spec_dict['function_signatures'][f]['signatures']):
            args_summary = ''
            args_list = []
            arg_idx = 0
            for arg_idx, arg in enumerate(spec_dict['function_signatures'][f]['signatures'][argset_idx]['arguments']):
                if arg['type'] in ['Function', 'Modifier']:
                    vals = [spec_dict['function_to_short'].get(val, spec_dict['modifier_to_short'].get(val)) for val in arg['values']]
                    args_summary += '|'.join(vals) + "()"
                    arg_idx += 1

                    if arg.get('optional', False) and arg.get('multiple', False) is False:
                        args_summary += '?'
                        text = f'Zero or one of each function(s): {", ".join([val for val in arg["values"]])}'
                    elif arg.get('optional', False):
                        args_summary += "*"
                        text = f'Zero or more of each function(s): {", ".join([val for val in arg["values"]])}'
                    else:
                        text = f'One of following function(s): {", ".join([val for val in arg["values"]])}'

                elif arg['type'] in ['NSArg', 'StrArg', 'StrArgNSArg']:
                    args_summary += f'{arg["type"]}'
                    if arg.get('optional', False) and arg.get('multiple', False) is False:
                        args_summary += '?'
                        if arg['type'] in ['NSArg']:
                            text = f'Zero or one namespace argument of following type(s): {", ".join([val for val in arg["values"]])}'
                        elif arg['type'] == 'StrArgNSArg':
                            text = f'Zero or one amespace argument or default namespace argument (without prefix) of following type(s): {", ".join([val for val in arg["values"]])}'
                        else:
                            text = f'Zero or one string argument of following type(s): {", ".join([val for val in arg["values"]])}'
                    elif arg.get('optional', False):
                        args_summary += "+"
                        if arg['type'] in ['NSArg']:
                            text = f'Zero or more namespace arguments of following type(s): {", ".join([val for val in arg["values"]])}'
                        elif arg['type'] == 'StrArgNSArg':
                            text = f'Zero or more namespace arguments or default namespace arguments (without prefix) of following type(s): {", ".join([val for val in arg["values"]])}'
                        else:
                            text = f'Zero or more of string arguments of following type(s): {", ".join([val for val in arg["values"]])}'
                    else:
                        if arg['type'] in ['NSArg']:
                            text = f'Namespace argument of following type(s): {", ".join([val for val in arg["values"]])}'
                        elif arg['type'] == 'StrArgNSArg':
                            text = f'Namespace argument or default namespace argument (without prefix) of following type(s): {", ".join([val for val in arg["values"]])}'
                        else:
                            text = f'String argument of following type(s): {", ".join([val for val in arg["values"]])}'

                args_summary += ', '
                args_list.append(text)

            args_summary = re.sub(', $', '', args_summary)
            spec_dict['function_signatures'][f]['signatures'][argset_idx]['argument_summary'] = f'{f}({args_summary})'
            spec_dict['function_signatures'][f]['signatures'][argset_idx]['argument_help_listing'] = args_list

            # print(f'{f}({args_summary})')
            # print(args_list)

    return spec_dict


def add_relations(spec_dict: Mapping[str, Any]) -> Mapping[str, Any]:
    """Add relation keys to spec_dict

    Args:
        spec_dict (Mapping[str, Any]): bel specification dictionary

    Returns:
        Mapping[str, Any]: bel specification dictionary with added relation keys
    """

    # TODO: PyCharm gives warning when instantiating the list and the two dicts below in spec_dict:
    # Class 'Mapping' does not define '__setitem__', so the '[]' operator cannot be used on its instances
    spec_dict['relation_list'] = []
    spec_dict['relation_to_short'] = {}
    spec_dict['relation_to_long'] = {}

    for relation_name in spec_dict['relations']:

        abbreviated_name = spec_dict['relations'][relation_name]['abbreviation']
        spec_dict['relation_list'].extend((relation_name, abbreviated_name))

        spec_dict['relation_to_short'][relation_name] = abbreviated_name
        spec_dict['relation_to_short'][abbreviated_name] = abbreviated_name

        spec_dict['relation_to_long'][abbreviated_name] = relation_name
        spec_dict['relation_to_long'][relation_name] = relation_name

    return spec_dict


def add_functions(spec_dict: Mapping[str, Any]) -> Mapping[str, Any]:
    """Add function keys to spec_dict

    Args:
        spec_dict (Mapping[str, Any]): bel specification dictionary

    Returns:
        Mapping[str, Any]: bel specification dictionary with added function keys
    """

    # TODO: PyCharm gives warning when instantiating the list and the two dicts below in spec_dict:
    # Class 'Mapping' does not define '__setitem__', so the '[]' operator cannot be used on its instances
    spec_dict['function_list'] = []
    spec_dict['function_to_short'] = {}
    spec_dict['function_to_long'] = {}

    for func_name in spec_dict['functions']:

        abbreviated_name = spec_dict['functions'][func_name]['abbreviation']

        spec_dict['function_list'].extend((func_name, abbreviated_name))

        spec_dict['function_to_short'][abbreviated_name] = abbreviated_name
        spec_dict['function_to_short'][func_name] = abbreviated_name

        spec_dict['function_to_long'][abbreviated_name] = func_name
        spec_dict['function_to_long'][func_name] = func_name

    return spec_dict


def add_modifiers(spec_dict: Mapping[str, Any]) -> Mapping[str, Any]:
    """Add modifier keys to spec_dict

    Args:
        spec_dict (Mapping[str, Any]): bel specification dictionary

    Returns:
        Mapping[str, Any]: bel specification dictionary with added modifier keys
    """

    # TODO: PyCharm gives warning when instantiating the list and the two dicts below in spec_dict:
    # Class 'Mapping' does not define '__setitem__', so the '[]' operator cannot be used on its instances
    spec_dict['modifier_list'] = []
    spec_dict['modifier_to_short'] = {}
    spec_dict['modifier_to_long'] = {}

    for modifier_name in spec_dict['modifier_functions']:

        abbreviated_name = spec_dict['modifier_functions'][modifier_name]['abbreviation']

        spec_dict['modifier_list'].extend((modifier_name, abbreviated_name))

        spec_dict['modifier_to_short'][abbreviated_name] = abbreviated_name
        spec_dict['modifier_to_short'][modifier_name] = abbreviated_name

        spec_dict['modifier_to_long'][abbreviated_name] = modifier_name
        spec_dict['modifier_to_long'][modifier_name] = modifier_name

    return spec_dict


def get_bel_versions() -> List[str]:
    """Get BEL Language versions supported

    Get the list of all BEL Language versions supported.  The file this depends
    on is generated by belspec_yaml2json and is kept up to date using
    `make update_ebnf` or `make update_parsers`.  You can also run `belspec_yaml2json`
    directly as it's added as a command by pip install.

    Returns:
        List[str]: list of versions
    """

    fn = f'{os.path.dirname(__file__)}/versions/bel_versions.json'
    with open(fn, 'r') as f:
        versions = json.load(f)

    return versions


def enhance_function_signatures(spec_dict: Mapping[str, Any]) -> Mapping[str, Any]:
    """Enhance function signatures

    Add required and optional objects to signatures objects for semantic validation
    support.

    Args:
        spec_dict (Mapping[str, Any]): bel specification dictionary

    Returns:
        Mapping[str, Any]: return enhanced bel specification dict
    """

    for func in spec_dict['function_signatures']:
        for i, sig in enumerate(spec_dict['function_signatures'][func]['signatures']):
            args = sig['arguments']
            req_args = []
            pos_args = []
            opt_args = []
            mult_args = []
            for arg in args:
                if arg.get('multiple', False):
                    if arg['type'] in ['Function', 'Modifier']:
                        mult_args.extend(arg.get('values', []))
                    elif arg['type'] in ['StrArgNSArg', 'NSArg', 'StrArg']:
                        mult_args.append(arg['type'])
                elif arg.get('optional', False) and arg.get('position', False):
                    if arg['type'] in ['Function', 'Modifier']:
                        pos_args.append(arg.get('values', []))
                    elif arg['type'] in ['StrArgNSArg', 'NSArg', 'StrArg']:
                        pos_args.append(arg['type'])
                elif arg.get('optional', False):
                    if arg['type'] in ['Function', 'Modifier']:
                        opt_args.extend(arg.get('values', []))
                    elif arg['type'] in ['StrArgNSArg', 'NSArg', 'StrArg']:
                        opt_args.append(arg['type'])
                else:
                    if arg['type'] in ['Function', 'Modifier']:
                        req_args.append(arg.get('values', []))
                    elif arg['type'] in ['StrArgNSArg', 'NSArg', 'StrArg']:
                        req_args.append(arg['type'])

            spec_dict['function_signatures'][func]['signatures'][i]['req_args'] = copy.deepcopy(req_args)
            spec_dict['function_signatures'][func]['signatures'][i]['pos_args'] = copy.deepcopy(pos_args)
            spec_dict['function_signatures'][func]['signatures'][i]['opt_args'] = copy.deepcopy(opt_args)
            spec_dict['function_signatures'][func]['signatures'][i]['mult_args'] = copy.deepcopy(mult_args)

    return spec_dict


def enhance_default_namespaces(spec_dict: Mapping[str, Any]) -> Mapping[str, Any]:
    """Enhance the default namespaces dictionary

    Add names and abbreviations of each default_namespace type to a key of type
    (e.g. ProteinModification or Activity) so that one can check for existence
    of a

    Args:
        spec_dict (Mapping[str, Any]): bel specification dictionary

    Returns:
        Mapping[str, Any]: bel specification dictionary with added default namespace lists
    """

    new_ns = {}

    for ns in spec_dict['default_namespaces']:
        ns_type = spec_dict['default_namespaces'][ns]['type']
        values = spec_dict['default_namespaces'][ns]['values']
        new_ns[ns_type] = []
        for val in values:
            new_ns[ns_type].append(val['name'])
            new_ns[ns_type].append(val['abbreviation'])

    for ns_type in new_ns:
        spec_dict['default_namespaces'][ns_type] = copy.deepcopy(new_ns[ns_type])

    return spec_dict



def main():
    import timy
    with timy.Timer() as timer:
        belspec_yaml2json()
        print(timer)


if __name__ == '__main__':
    main()
